- Feature Name: Zmix project API and layout
- Start Date: 2020-06-15
- RFC PR:
- Ursa Issue:
- Version: 1

# Summary
[summary]: #summary

Zmix aims to provide a common API that provide zero-knowledge proofs based on three distinct but not exclusive roles:

- Issuer: any entity that issues credentials to holders. Issuers control what types of signatures to use, to whom they issue,
criteria for issuance, credential validity periods, and revocation registries if desired.
- Holder/Prover: any entity that obtains credentials, manages credentials or secrets, and proves to another party in zero-knowledge information about themselves or others.
- Verifier: any entity that checks zero-knowledge proofs and is convinced of their truthfulness or not.

# Motivation
[motivation]: #motivation

Ursa is beginning to have many primitives that serve to construct a la carte zero-knowledge methods. 
Unfortunately, there hasn't been a project plan until now for organizing and layering these primitives together.

There are two ways this can be done in Rust: feature flags or subprojects. Feature flags alone become complicated
as projects grow, confusing end consumers. Subprojects are great for organizing common features and code, but 
lines become blurred when common features surface. Zmix will use the best of both worlds. Similar to other rust projects, 
Zmix will subdivide primitives into subprojects and provide a top level API for easy consumption like Serde, Rand, and Rayon.

Serde provides a top level API that supports the common features used for serializing and deserializing data in Rust.
The exact encodings are domain specific and left up to the end user, but included in projects by specifying either features
in serde or including subprojects. Zmix will be organized in a similar way.

# Guide-level explanation
[guide-level-explanation]: #guide-level-explanation

Zero-knowledge proofs can be divided into the following categories:

- Predicates: prove knowledge about statements like inequalities, ranges, and set memberships
- Knowledge proofs: prove knowledge about statements like signatures and commitments.

Knowledge proofs tend to center around using credentials like cryptographic signatures, proving knowledge of the signature
instead of revealing it, or proving knowledge of committed values. Signatures may be generated by third-parties (Issuers) or self-attested
by the Provers themselves. Credentials are signatures over 1 or more attributes or claims. Attributes may or may not be disclosed
in a proof, but that is the extent of knowledge proofs. We divide signature schemes into the following groups:

1. Simple signatures where attributes or data are signed by a single signature and proved using traditional cryptographic methods (ECDSA, Ed25519, RSA).
1. Attribute-based credentials (ABC) where a credential is obtained on a set of attributes and then, according to the properties of the signature,
it is possible either to prove the knowledge of a subset of the attributes ([CL02](https://groups.csail.mit.edu/cis/pubs/lysyanskaya/cl02b.pdfhttps://groups.csail.mit.edu/cis/pubs/lysyanskaya/cl02b.pdf),
[BBS+](https://crypto.stanford.edu/~xb/crypto04a/groupsigs.pdf),
[PS](https://eprint.iacr.org/2015/525.pdf),
[CDLNT](https://eprint.iacr.org/2020/016.pdf),
[FHS](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.400.8540&rep=rep1&type=pdf), blind signatures)
1. Sanitizable signatures where some attributes are modified to default values prior to presentation ([CL13](https://dl.acm.org/doi/pdf/10.1145/2484313.2484363))
1. Unlinkable Redactable signatures where some attributes are removed prior to presentation ([CDHK](https://eprint.iacr.org/2015/580.pdf),
[San20](https://eprint.iacr.org/2019/1201.pdf),
SPS-EQ with set commitments [FHS14](https://eprint.iacr.org/2014/944.pdf)
)
1. ABC signatures where the user receives one credential per attribute and then combines them (aggregatable signatures [CL11](https://dl.acm.org/doi/pdf/10.1145/2046642.2046655))

Predicate proofs tend to center around proving subsets of details about attributes or data in credentials without revealing the entire
value. For example, revocation can be verified against a specific registry without revealing the credential identification number, or
the credential validity period can be checked by comparing the current date to the expiration date. Predicates are divided into the following groups:

1. Range proofs where a number is validated to be between an upper and lower bound.
1. Membership proofs where a value is proven against a set of elements as inclusive (value is in the set) or exclusive (value is not in the set).
1. Custom Circuit proofs where proofs do not fall in the previous two, typically custom logic (zk-SNARKs or R1CS circuits).

This RFC does not cover communication between Issuers, Provers, or Verifiers.

## Issuers
[issuers]: #issuers
Issuers publish signature verification keys to trusted oracles, (either under their control or 
the control of a trusted party) and manage credentials that have been issued (revoking
them if incorrect data was signed or in the case of credential abuse or fraud). 

This RFC defines the following functions needed by Issuers:

- GenerateKeys: Create digital signature keys
- GenerateSign: Create a digital signature
- GenerateBlindSign: Create a blind digital signature
- RevokeSignature: Revoke a digital signature
- UpdateKeys: Change digital signature keys to new keys or nullify to revoke
- GenerateRevocationRegistry: Create a registry used for checking if a digital signature is currently valid
- UpdateRevocationRegistry: Add or remove entries in a revocation registry or nullify to invalidate

## Holders
[holders]: #holders

Holders receive ABC credentials from Issuers, hold data, and prove statements about data to Verifiers.
The data included in proofs may be from credentials received from Issuers or self-attest data.
This RFC defines the functions needed by Holders:

- PrepareBlindSign: Prepare data to be signed blindly by an Issuer
- UnblindSignature: Unblind a blind signature received from an Issuer
- GenerateSPoK: Create a zero-knowledge proof for a signature
- GeneratePoCV: Create a zero-knowledge proof of committed values
- GeneratePredicate: Create a predicate proof

Predicates do not necessarily need to be tied to credentials to be used.

## Verifiers
[verifiers]: #verifiers

Verifiers validate received proofs and signatures. 
This RFC defines the following functions needed by Verifiers:

- VerifySignature: Check if a signature is valid
- VerifyProof: Verify a zero-knowledge proof: signature, commitment, and/or predicate.

# Reference-level explanation
[reference-level-explanation]: #reference-level-explanation

Zmix defines the common top layer for Issuers, Holders, Verifiers and any other common methods used by all roles and
zero-knowledge proof primitives. Each subcrate will hold only one primitive and all functionality associated therein.

Below is the proposed structure

```
libzmix
   |
   --- zmix_common
          |
          --- utils
              errors
       zmix_signatures
          |
          --- bbs
              ps
              cl
              cdlnt
       zmix_accumulators
          |
          --- rsa
              hyperelliptic
              cks
              merkle
       zmix_predicates
           |
           --- bulletproofs
               snarks
               r1cs
       zmix_core
           |
           --- issuer
               holder
               verifier
       Cargo.toml
```

`common` is used for traits and logic shared across 2 or more subcrates.

`core` is organized according to the three roles of the zero-knowledge protocols. This is the main crate that will be included in other projects.

`signatures` are signatures that can be used to generate signature proofs of knowledge with selective disclosure proofs.
Current signatures known to support this scheme are [BBS+](https://crypto.stanford.edu/~xb/crypto04a/groupsigs.pdf), [CL](https://groups.csail.mit.edu/cis/pubs/lysyanskaya/cl02b.pdfhttps://groups.csail.mit.edu/cis/pubs/lysyanskaya/cl02b.pdf),
[PS](https://eprint.iacr.org/2015/525.pdf), [CDLNT](https://eprint.iacr.org/2020/016.pdf), and [delegatable credentials](https://acmccs.github.io/papers/p683-camenischA.pdf). There will be common code shared among signatures
like interfaces and errors.

`accumulators` are used for zero-knowledge set memberships. Current known schemes are accumulators of unknown order like 
[RSA](https://eprint.iacr.org/2018/1188.pdf) and [Hyperelliptic Curves](https://eprint.iacr.org/2020/196.pdf), Elliptic Curve based like [CKS](https://link.springer.com/content/pdf/10.1007%2F978-3-642-00468-1_27.pdf), and [Merkle Tree](https://eprint.iacr.org/2019/1255.pdf) based.

`predicates` are proofs for testing ranges and inequalities of [numeric](https://eprint.iacr.org/2017/1066.pdf) inputs or
             other miscellaneous circuit based proofs like [PLONK](https://eprint.iacr.org/2019/953.pdf) or [SPARTAN](https://eprint.iacr.org/2019/550.pdf) and
             [Verifiable Encryption](https://www.shoup.net/papers/verenc.pdf)

# Drawbacks
[drawbacks]: #drawbacks

Creating the initial interfaces and APIs will be challenging and may slow down progress.

# Rationale and alternatives
[alternatives]: #alternatives

The project could be organized by rust features alone. 
This would have multiple drawbacks: 
- cfg syntax sprinkled throughout the code,
- lots of combinations in Cargo.toml, 
- the difficulty of keeping in mind all the various features when adding or modifying code. 

This would make for a monolithic project that is consumable by users but requires documenting all features 
and complex combinations and coding for dangerous combinations.

The project could be organized by just subcrates with no common API and consumers could pick and choose each one to use.
The disadvantage would be code duplication across projects and the lack of a common API.

# Prior art
[prior-art]: #prior-art

## Good examples

[Rand](https://github.com/rust-random/rand)

[Crossbeam](https://github.com/crossbeam-rs/crossbeam)

[RustCrypto Hashes](https://github.com/RustCrypto/hashes)

[RustCrypto Encryption](https://github.com/RustCrypto/traits)

## Bad examples

[libursa](https://github.com/hyperledger/ursa/blob/master/libursa/Cargo.toml)

# Unresolved questions
[unresolved]: #unresolved-questions

# Changelog
[changelog]: #changelog

- [15 Jun 2020] - v1 - Initial draft
